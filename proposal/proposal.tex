\documentclass[12pt]{article}

\usepackage{natbib}
\usepackage[cm]{fullpage}
\usepackage{graphicx}
\pagenumbering{gobble}

\linespread{1.00}

\usepackage{titlesec} % Allows customization of titles

\setlength\parindent{24pt}

\usepackage[
  top    = 2.50cm,
  bottom = 1.50cm,
  left   = 1.50cm,
  right  = 1.50cm]{geometry}

\usepackage{setspace}

\title{\vspace{-25mm}\fontsize{16pt}{10pt}\selectfont\textbf{Proposal}} % Article title

\author{
  \textsc{William Morriss} \\
  \textsc{Thomas Kim}
}
\date{}

\begin{document}

\maketitle % Insert title
% Timeline Project is due 12/02

\section{Overview}
An improved version of 'cp -r' is proposed.
This version will take advantage of Linux's asynchronous IO interfaces to create
opportunities for parallelism, and will minimize the time spent blocking on disk
IO by leveraging fallocate and readahead. Furthermore, to ensure no requests to
paged out pages in the buffer are blindly initiated, a kernel module to service
requests from dcp for page table entries is proposed. In order to ensure reads
always result in hits in the buffer cache, POSIX fadvise will be used. To ensure optimal
layout of files for writing, POSIX fallocate will be used. As an alternative to
using fadvise, an alternate implementation which uses mmap and madvise instead will
be compared to the initial implementation.

\section{Key features}
\subsection{General optimizations}
\begin{itemize}
    \item Hard links will be detected and the associated inode and file will
          only be read once.
    \item st\_atime updates will be suppressed using O\_NOATIME
\end{itemize}
\subsection{Asynchronous I/O}
Dcp will use asynchronous I/O to populate a per-thread in-memory buffer.
Both fixed-size and adaptive-sized buffers will be tested.
For adaptive sizing of the buffer, the size of physical memory
and number of free physical pages will be considered when allocating
the buffer, and can be resized at a regular interval based on system load.
Requests for both reads and writes will be made using the POSIX AIO interface
\cite{manaio}.

\subsection{Multithreading}
Three alternatives for multithreading will be compared for dcp,
threaded synchronous I/O, threaded asynchronous I/O, and unthreaded
asynchronous I/O (\textit{see section 3}). A single program which
can take explicit parameters to modify the number of threads and
type of I/O will be implemented to test these.

Multithreading will be accomplished by using 2 MPMC queues,
one for directories and one for files. Since the reading of
directories is required to queue work for files, threads
reading directories will be prioritized over those writing files.
Since the time taken to read a large file is dominated by
the sequential read time, as opposed to the seek time overhead
when reading a small file, small files will be prioritized over
large files.

The level of concurrency will be dynamically adjusted based
on the characteristics of the workload and the performance
of dcp during execution.

\subsection{Adaptive buffer sizing}
As mentioned in the previous section on asynchronous I/O, an adaptive
sizing of the per-thread buffer will be implemented and evaluated for
performance. The combination of increasing the size of the buffer for
larger physical memory sizes and FADV\_SEQUENTIAL, disk idle time could
possibly be reduced by allowing for larger concurrent read requests.
For systems with older and slower disks, as well as directory trees
with a large number of very small files, having a larger buffer
will not necessarily positively affect dcp's efficiency.

\subsection{Readahead}
POSIX fadvise will be used to ensure that pages will be available
in the buffer cache when read, and that pages will be evicted from
the cache as soon as possible. Both reads and writes in dcp will
generally (\textit{see Page Presence Tracking}) be sequential.

\subsection{Mmap and madvise}
As an alternative to reading files using asynchronous I/O and fadvise,
mmap and madvise could be used. By using MADV\_SEQUENTIAL when mmapping
files, mmap's demand paging can be leveraged to quickly sequentially access
the underlying file. This has the advantage that only one copy of each
page of the file will be created, but requires awareness of the buffer
cache replacement policy.

\subsection{Page Presence Tracking}
In order for dcp to be aware of any pages in the per-thread buffer that
are paged out, a kernel module to fetch and return page table entries to
dcp is proposed. Using the page table entries, dcp will have a better
idea of whether the next sequential page in the buffer is in memory,
and can make asynchronous IO requests for pages that are in memory
before page faulting for those pages which were paged out.

\subsection{Fallocate}
POSIX fallocate will be used to allow the destination filesystem to
allocate blocks in an efficient way. The use of fallocate is
fairly straightforward and is expected to increase write speeds
provided the filesystem on the destination disk intelligently
allocates blocks.

\section{Benchmarking methodology}
Dcp will be testable on commonly available computer hardware, and will be tested on
consumer-grade personal computers. Dcp will be tested on both solid state drives
and traditional platter based hard drives, with file transfers going from one disk to
another or one disk to itself, as well as through internal SATA II interfaces and
external USB3.0 interfaces. The hardware necessary to test dcp will be provided through
the personal computers of the researchers involved in dcp. The disks used to test dcp
will be formatted in ext4.

For all hardware configurations, four independent variables will be considered when
creating benchmarks:
\begin{itemize}
    \item File size
    \item Number of files
    \item Number of directories
    \item Depth of directory tree
\end{itemize}

A simple program will be used to hash the input files, invoke dcp, measure the
execution time, then verify that all transfers were completed
successfully by comparing the directory trees and file hashes between
the source and destination directories.

\section{Timeline}
This project will follow a weekly timeline. \\
\begin{tabular}{|l | l|}
\hline
10/20 & Fixed-size/adaptive-size buffer complete \\
10/27 & fadvise/fallocate complete \\
11/03 & mmap/madvise complete \\
11/10 & MPMC complete \\
11/17 & Testing/debug \\
11/24 & Benchmarking \\
12/01 & Complete \\
\hline
\end{tabular}

\bibliographystyle{plain}
\bibliography{citations}
\end{document}
